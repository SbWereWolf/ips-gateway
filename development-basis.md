# Введение

Всё ниже изложенное следует понимать в рамках Шлюза СБП, предложения и
требования изложенные ниже относятся только к Шлюзу СБП.

Чем проще система тем выше её надёжность, тем быстрее поиск
неисправностей и соответственно их устранение. На первом этапе
разработки предполагается использование самых примитивных реализаций,
с самой примитивной инфраструктурой.

В каждой следующей итерации возможно усложнение инфраструктуры.

# Требования к ПО

Любое ПО разрабатывается для использования. Использование ПО для
конечного пользователя должно быть не сложным по навыкам и не трудным
по усилиям.

Любое ПО требует обслуживания: настройки и ремонта.

## Настройка

Настройка должна быть примитивной, но иметь запас гибкости, что бы в
текущей работе не требовалось переработки ПО. Параметры работы которые
могут измениться в процессе работы с ПО, должны изменяться без
привлечения разработчиков.

## Ремонт

Ремонт сбоев в работе ПО должен быть быстрым. Ремонт будет быстрым
если ПО позволит быстро определить место сбоя и предоставит значимую
информацию о причинах сбоя.

ПО должно вести журнал своей работы, в журнал должна записываться
только значимая информация. При сбоях, ПО должно (в журнале) объяснить
почему оно сломалось и что с этим делать.

## Проверка качества (тестирование работоспособности)

Для проверки качества ремонта должно требоваться минимум усилий и
минимум ресурсов. ПО должно запуститься с минимальными требованиями к
ресурсам и минимальными потребностями во внешних системах, проверка 
должна быть выполнена за минимальное время.

На каждую функцию ПО (каждый сценарий использования) должна быть 
разработана автоматическая проверка.

# Предложения по разработке

## Общие принципы

ПО всегда меняется. Меняются отдельные этапы работы ПО:
* изменяются отдельные бизнес процессы,
* изменяются интеграции с внутренними системами (кэш, БД, очередь 
сообщений, веб сервер, аргументы командной строки),
* изменяются интеграции с внешними системами (новые версии протокола 
сообщений СБП, новые версии API СБП, Макробанк, АБС, процессинг 
карт).

Для упрощения внесения изменений в работу ПО каждый этап работы ПО 
должен быть изолированной частью ПО, отделённой от прочих частей 
(модулей). Связи между модулями ПО должны происходить через 
программные интерфейсы (или аргументы командной строки), эти 
программные интерфейсы не должны отражать внутреннюю работу модуля.

## Отдельные этапы - отдельные программы

Для упрощения тестирования и снижения требований к ресурсам 
необходимым для запуска ПО отдельные части ПО должны быть отдельными 
исполняемыми файлами (отдельными программами). Совокупность таких 
программ будет образовывать ПО в целом.

Разработка должна строиться исходя из философии UNIX:
* пишите программы, которые делают что-то одно и делают это хорошо;
* пишите программы, которые бы работали вместе;
* пишите программы, которые бы поддерживали текстовые потоки, 
поскольку это универсальный интерфейс.

Взаимодействие программ должно быть организовано через обмен 
текстовыми сообщениями, так что бы можно было выстроить конвейер 
обработки текстового ввода.

Соответственно работа программ должна происходить в синхронном режиме.
Все этапы обработки текстового ввода должны быть пройдены, прерывание 
обработки возможно только при возникновении непредвиденной 
исключительной ситуации.

## Общий код в общие библиотеки

Для уменьшения повторяющегося кода, повторы кода следует выносить в 
пакеты (библиотеки). Несколько программ могут использовать одну и туже
библиотеку или набор библиотек. При необходимости обновления в работе 
библиотеки создаётся новая версия, при этом часть программ может 
работать со старой библиотекой, а часть - с новой.

Аналогично со структурами данных, каждая запись данных должна 
содержать мета информацию о версии формата данных. В хранилище данные 
могут быть записаны в форматах разных версий.

## Требования к программам

Каждая программа должна иметь возможность настройки своей работы 
(через аргументы командной строки или через конфигурационный файл).

Каждая программа должна вести журнал своей работы.

На каждую программу должны быть написаны автоматически тесты по 
каждому варианту использования, в которых на заданный текстовый ввод 
будет получен ожидаемый текстовый вывод.

# Предложения по развёртыванию

Функционал ПО реализуется через конвейер состоящий из программ, каждая
программа это исполняемый файл и файл конфигурации.

Каждая программа ведёт журнал своей работы.

## Размещение файлов программ.

Файлы размещаются в файловой системе, для уменьшения времени чтения 
эти файлы можно разместить в оперативной памяти на RAM-диске 
[инструменты для создания RAM-диска|https://en.wikipedia.org/wiki/List_of_RAM_drive_software].

Операционная система при загрузке должна создавать такой RAM-диск и 
копировать на него:
* файлы программ;
* файлы библиотек;
* файлы конфигурации;

Для записи временных файлов (lock-файлы, файлы с промежуточными 
результатами работы для обработки другими программами) следует 
использовать "быстрый" RAM-диск. Временные файлы должны удаляться с 
некоторой периодичностью.

## Размещение файлов журналов

Программы должны вести журнал своей работы для использования этих 
журналов при расследовании сбоев. Журналы должны быть "прочными" - 
аварийное завершение работы программы или операционной системы, не 
должно привести к разрушению журнала или утери части записей.

Журналы следует записывать в постоянную энергонезависимую память, 
такая запись требует значительного времени по сравнению с записью в 
оперативную память, поэтому запись должна вестись асинхронно.

# Оценка предложенного подхода

## Преимущества

1. Размещение ограниченного функционала в отдельной программе требует
меньше ресурсов для её загрузки, по сравнению с загрузкой программы в
которой реализован весь функционал (загружаются только необходимый 
код, только необходимые библиотеки).
2. Физическое разделение функционала между отдельными исполняемыми 
файлами исключает сквозную связность в казалось бы не связанных частях
кода.
3. Использование конвейера программ исключает необходимость
организации обмена данными между отдельными частями программы.
4. Отдельный исполняемый файл можно протестировать примитивными
средствами командной строки, такое тестирование не требует ни каких
навыков, кроме умения скопировать, вставить и снова скопировать то что
выдаст программа. Такое тестирование можно автоматизировать средствами
операционной системы.
5. Разделение функционала между отдельными программами позволяет
заменять одну версию программы на другую без необходимости полного
тестирования, достаточно тестирования только функционала
реализованного в одной программе.
6. Разделение функционала между отдельными программами позволяет
разделить код на независимые репозитории работа над которыми может
вести независимыми "командами" разработчиков, тем самым исключается
необходимость разрешения конфликтов при слиянии изменений, поскольку
каждая команда будет вносить изменения только в свой репозиторий.

## Недостатки

1. Поскольку функционал разделён на несколько независимых программ, то
для целостного понимания необходимо знать последовательность работы
этих программ. Что бы отследить как происходит работа ПО недостаточно
просто "провалиться" в код точки входа, придётся "прыгать" между
различными точками входа.
2. Необходимость иметь множество репозиториев. Необходимость
использования сабмодулей.
3. Необходимость реализации RAM-диска.
4. Отсутствие "встроенного" мониторинга внутренней работы комплекса ПО
(нет панели показателей количества сообщений, средней длины очереди
сообщений)
5. Отсутствие "встроенного" механизма автоматического запуска и
остановки программ.
6. Отсутствие показателей количества одновременно работающих
экземпляров ПО, отсутствие "встроенной" возможности ограничить
количество одновременно работающих экземпляров ПО.

# Пример реализации

## Бизнес-логика

Для примера возьмём обработку входящего запроса от СБП.

Обработка состоит из трёх частей:
 - из запроса СБП извлечь бизнес сообщение
 - из сообщения извлечь значимые бизнес данные
 - данные передать в Макробанк

На каждый этап разработаем отдельную бизнес-логику (библиотеку):
 - извлечь сообщение - *concierge*
 - извлечь значимые данные - *ips-message-parser*
 - передать данные в Макробанк - *payload-processor*

## Использование бизнес-логики

Для работы с библиотеками необходима программа которая будет принимать
данные, передавать их на обработку в библиотеку, получать результат 
обработки и выдавать этот результат.

Ввод и вывод может происходить через любой носитель:
* командная строка,
* очередь сообщений,
* файлы,
* база данных,
* чат бот,
* что угодно ещё.

В нашем случаем используем командную строку для ввода и вывода.

Соответственно разрабатываем программы:
- concierge.CLI,
- ips-message-parser.CLI,
- payload-processor.CLI.

## Библиотека для работы с командной строкой

Работа с командной строкой во всех трёх программах происходит 
одинаково:
1. считать настройки из файла конфигурации
2. получить аргументы запуска
3. получить текстовый ввод из командной строки
4. создать экземпляр класса обработчика
5. применить к экземпляру настройки
6. выполнить обработку с помощью экземпляра
7. вывести результат в командную строку

Шаги 1-2-3-7 требуются всегда и не зависят от специфики обработчика, 
эти действия можно вынести в библиотеку и использовать её во всех 
программах - разрабатываем библиотеку command-line-interface.

Соответственно каждая из CLI программ (например concierge.CLI) 
использует библиотеку с бизнес-логикой (например concierge) и 
библиотеку с инфраструктурой командной строки - 
command-line-interface.

Собственно написание программы сводиться к такому коду:


```
using CommandLineInterface;
namespace Concierge.CLI
{
    public class Program : BaseProgram
    {
        private const int MediumIndex = 0;
        private const int OptionsIndex = 1;
        protected const string SettingsKey = "concierge-settings-file";
        public static void Main(string[] args)
        {
            var app = new Program(SettingsKey);
            var arguments = app.Startup(args);
            app.Run(arguments);
        }
        public Program(string settingsPathKey) : base(settingsPathKey)
        {
        }
        protected override void Run(ArgumentStorage arguments)
        {
            var medium = arguments.Extract(
                MediumIndex,
                "Тип источника сообщений не задан"
                );
            var options = arguments.Extract(
                OptionsIndex,
                "Не определены настройки получения сообщений из источника"
                );
            OutputMessages(medium, options);
        }
        private static void OutputMessages(string medium, string options)
        {
            foreach (var message in ReadMessages(medium, options))
            {
                Console.WriteLine(message);
            }
        }
        private static IEnumerable<string> ReadMessages(string medium, string options)
        {
            var reader = new ReadingInboxLibrary.InboxReaderFactory().Make(medium);
            reader.GetReadyForReading(options);
            foreach (var body in reader.LetReadTheMessages())
            {
                yield return body;
            }
        }
    }
}
```
Бизнес-логика описана в методе Run(ArgumentStorage arguments), и 
вместе с методами OutputMessages и ReadMessages занимает меньше 50-ти 
строк.

Писать программы обёртки легко. Тесты пишутся ещё проще.

## Настройка работы программы

При запуске любая программа имеет доступ к трём ресурсам:
- процессор
- оперативная (временная) память
- постоянная память

Будет ли доступна сеть на момент запуска ни чем не гарантировано, но 
первым дело при запуске программа должна себя настроиться на работу.

Поэтому настройки для работы программы можно гарантированно прочитать
только из постоянной памяти (файловой системы).

Соответственно считываем настройки из файловой системы. В этих
настройках может быть сконфигурировано дальнейшее поведение - чтение
дополнительных настроек из локально развёрнутых сервисов (СУБД, кэш 
и т.п.) или из этих же сервисов, но развёрнутых удалённо - доступных
по сети.

Но исходно настройки следует считывать из файловой системы.

Этот функционал реализован в библиотеке command-line-interface 
(класс BaseProgram), при необходимости его можно переопределить или
дополнить.

## Ведение журнала работы

Ведение журналы работы это единственный способ для расследования
происшествий (аварий в работе ПО), его запись это критичный функционал,
если он не доступен, то программа не должна выполняться.

Ведение журнала работы не должно задерживать выполнение основного 
потока программы. Журнал должен записываться асинхронно.

Ведение журнала работы обеспечивается декоратом (LoggingDecorator) для
произвольного класса. Декоратор записывает с какими аргументами был 
запущен каждый метод и с каким результатом он завершился. Каждый 
аргумент метода и его результат должен иметь реализацию метода 
ToString(), для записи его значения в строковый журнал.

Запись выполняется только для методов реализующих какой-либо 
интерфейс, поэтому для классов, вызовы которых требуется записывать,
необходимо создать интерфейс.

Декоратор это обертка для экземпляра класса. Для оборачивания класса в
декоратор необходимо использовать Фабрику.

Каждый экземпляр класса ведёт свой журнал, на один запуск программы 
записывается несколько файлов. Для сведения всех журналов в один
требуется отдельная программа. Также эта программа должна передавать
записи журналов в единое хранилище журналов работы.

Применение Декоратора вынуждает создавать интерфейсы и Фабрики, но это
скорее плюс, чем минус.

## Автоматические тесты

Программа, которая принимает строки и выдаёт строки,
удобна для ручного тестирования. Для тестирования достаточно самой
элементарной инфраструктуры - достаточно только консоли командной
строки и программы которая сравнит две строки (строку ожидаемый
результат со строкой реальным результатом выполнения программы).

Автоматические тесты сводятся к шаблонному коду:
```
    public class ParserReceiveXml : Terminal.Test.CLI.SingleStepTestAbstract
    {
        [Test]
        public void Test()
        {
            this.Run();
        }
        protected override string[] ConfigureArguments()
        {
            return Array.Empty<string>();
        }
        protected override StringReader DefineInput()
        {
            var input = File.ReadAllText(@".\data\input.xml");
            return new StringReader(input);
        }
        protected override void Act(string[] startupArguments)
        {
            IpsMessageParser.CLI.Program.Main(startupArguments);
        }
        protected override string TakeExpectedOutput()
        {
            return File.ReadAllText(@".\expected\ips-message-parser.CLI.stdout");
        }
    }
```

В одном методе задаём файл с текстовым вводом (DefineInput()), в
другом методе задаём ожидаемый текстовый вывод (TakeExpectedOutput()).

Если программа принимает аргументы запуска, то задаём их в 
ConfigureArguments().

Если программа требует какого-то конкретного окружения тестирования,
то создаём его с помощью восстановления состояния из резервных копий.
